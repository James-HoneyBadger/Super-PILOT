#!/usr/bin/env python3
# SuperPILOT Interpreter - Complete Implementation
# For integration with SuperPILOT II IDE

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, simpledialog
import random
import math
import re
import time
from datetime import datetime


class ToolTip:
    """Lightweight tooltip helper usable across the UI."""
    def __init__(self, widget, text, delay=500):
        self.widget = widget
        self.text = text
        self.delay = delay
        self.tipwindow = None
        self.id = None
        widget.bind('<Enter>', self.schedule)
        widget.bind('<Leave>', self.hide)

    def schedule(self, event=None):
        try:
            self.id = self.widget.after(self.delay, self.show)
        except Exception:
            self.id = None

    def show(self):
        if self.tipwindow or not self.text:
            return
        try:
            x = self.widget.winfo_rootx() + 20
            y = self.widget.winfo_rooty() + self.widget.winfo_height() + 5
            self.tipwindow = tw = tk.Toplevel(self.widget)
            tw.wm_overrideredirect(True)
            tw.wm_geometry(f"+{x}+{y}")
            label = tk.Label(tw, text=self.text, justify=tk.LEFT,
                             background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                             font=("Segoe UI", 9))
            label.pack(ipadx=4, ipady=2)
        except Exception:
            self.tipwindow = None

    def hide(self, event=None):
        if self.id:
            try:
                self.widget.after_cancel(self.id)
            except Exception:
                pass
            self.id = None
        if self.tipwindow:
            try:
                self.tipwindow.destroy()
            except Exception:
                pass
            self.tipwindow = None

class SuperPILOTInterpreter:
    def __init__(self, output_widget=None):
        self.output_widget = output_widget
        self.variables = {}
        self.labels = {}
        self.program_lines = []
        self.current_line = 0
        self.stack = []
        # For-loop stack: list of dicts with keys: var, end, step, for_line
        self.for_stack = []
        self.match_flag = False
        # Internal flag: set when a Y: or N: was the last command to allow
        # the immediately following T: to be treated as conditional.
        self._last_match_set = False
        self.running = False
        self.debug_mode = False
        self.breakpoints = set()
        
    def reset(self):
        """Reset interpreter state"""
        self.variables = {}
        self.labels = {}
        self.program_lines = []
        self.current_line = 0
        self.stack = []
        self.for_stack = []
        self.match_flag = False
        self._last_match_set = False
        self.running = False
        
    def log_output(self, text):
        """Log output to widget or console"""
        if self.output_widget:
            self.output_widget.insert(tk.END, str(text) + "\n")
            self.output_widget.see(tk.END)
        else:
            print(text)
            
    def parse_line(self, line):
        """Parse a program line for line number and command"""
        line = line.strip()
        match = re.match(r'^(\d+)\s+(.*)', line)
        if match:
            line_number, command = match.groups()
            return int(line_number), command.strip()
        return None, line.strip()
        
    def evaluate_expression(self, expr):
        """Safely evaluate mathematical expressions with variables"""
        # Replace variables.
        # First substitute explicit *VAR* interpolation (used in many programs).
        for var_name, var_value in self.variables.items():
            if isinstance(var_value, str):
                val_repr = f'"{var_value}"'
            else:
                val_repr = str(var_value)
            # Replace *VAR* occurrences first
            expr = expr.replace(f"*{var_name}*", val_repr)

        # Then replace bare variable names using word boundaries to avoid
        # accidental substring replacements (e.g. A vs AB).
        for var_name, var_value in self.variables.items():
            if isinstance(var_value, str):
                val_repr = f'"{var_value}"'
            else:
                val_repr = str(var_value)
            try:
                expr = re.sub(rf"\b{re.escape(var_name)}\b", val_repr, expr)
            except re.error:
                # fallback to plain replace if regex fails for unusual names
                expr = expr.replace(var_name, val_repr)
                
        # Safe evaluation of mathematical expressions
        try:
            # Allow basic math operations and functions
            allowed_names = {
                "abs": abs, "round": round, "int": int, "float": float,
                "max": max, "min": min, "len": len, "str": str,
                # RND accepts 0 or 1 args in many example programs
                "RND": (lambda *a: random.random()), "INT": int,
                "VAL": lambda x: float(x) if '.' in str(x) else int(x),
                "UPPER": lambda x: str(x).upper(), "LOWER": lambda x: str(x).lower(),
                "MID": (lambda s, start, length: str(s)[int(start)-1:int(start)-1+int(length)]
                        if isinstance(s, (str, int, float)) else ""),
            }
            
            # Create safe environment
            safe_dict = {"__builtins__": {}}
            safe_dict.update(allowed_names)
            
            # Replace custom functions
            expr = expr.replace("RND(1)", str(random.random()))
            expr = expr.replace("RND()", str(random.random()))
            
            result = eval(expr, safe_dict)
            return result
        except Exception as e:
            self.log_output(f"Expression error: {e}")
            return 0

    def interpolate_text(self, text: str) -> str:
        """Interpolate *VAR* tokens and evaluate *expr* tokens inside a text string.

        This central helper is used by T: and MT: to keep interpolation logic
        consistent and reduce duplication.
        """
        # First replace explicit variable occurrences like *VAR*
        for var_name, var_value in self.variables.items():
            text = text.replace(f"*{var_name}*", str(var_value))

        # Then evaluate expression-like tokens remaining between *...*
        try:
            tokens = re.findall(r"\*(.+?)\*", text)
            for tok in tokens:
                # If we've already replaced this as a variable, skip
                if tok in self.variables:
                    continue
                tok_stripped = tok.strip()
                # If token looks like a numeric literal, just use it
                if re.fullmatch(r"[-+]?\d+(?:\.\d+)?", tok_stripped):
                    text = text.replace(f"*{tok}*", tok_stripped)
                    continue
                # Heuristic: if token contains expression characters, try to eval
                if re.search(r"[\(\)\+\-\*/%<>=]", tok):
                    try:
                        val = self.evaluate_expression(tok)
                        text = text.replace(f"*{tok}*", str(val))
                    except Exception:
                        # leave token as-is on error
                        pass
        except Exception:
            pass

        return text
            
    def get_user_input(self, prompt=""):
        """Get input from user"""
        if self.output_widget:
            # Use dialog for GUI environment
            result = simpledialog.askstring("Input", prompt)
            return result if result is not None else ""
        else:
            # Use console input for command line
            return input(prompt)
            
    def execute_pilot_command(self, command):
        """Execute PILOT commands"""
        try:
            # Determine the command prefix up to the first colon (e.g., T:, A:, MT:)
            colon_idx = command.find(':')
            if colon_idx != -1:
                cmd_type = command[:colon_idx+1]
            else:
                cmd_type = command[:2] if len(command) > 1 else command
            
            if cmd_type == "T:":
                # Text output
                text = command[2:].strip()
                # If the previous command set a match (Y: or N:), then this T: is
                # treated as conditional and only prints when match_flag is True.
                if self._last_match_set:
                    # consume the sentinel
                    self._last_match_set = False
                    if not self.match_flag:
                        # do not print when match is false
                        return "continue"

                text = self.interpolate_text(text)
                self.log_output(text)
                return "continue"
                
            elif cmd_type == "A:":
                # Accept input
                var_name = command[2:].strip()
                prompt = f"Enter value for {var_name}: "
                value = self.get_user_input(prompt)
                # Try to convert to number if possible
                try:
                    if '.' in value:
                        self.variables[var_name] = float(value)
                    else:
                        self.variables[var_name] = int(value)
                except:
                    self.variables[var_name] = value
                return "continue"
                
            elif cmd_type == "Y:":
                # Match if condition is true
                condition = command[2:].strip()
                try:
                    result = self.evaluate_expression(condition)
                    self.match_flag = bool(result)
                except:
                    self.match_flag = False
                # mark that the last command set the match flag so a following T: can be conditional
                self._last_match_set = True
                return "continue"
                
            elif cmd_type == "N:":
                # Match if condition is false
                condition = command[2:].strip()
                try:
                    result = self.evaluate_expression(condition)
                    # N: treat like a plain conditional (match when the condition is TRUE).
                    # Many existing examples and tests use N: as an alternate test
                    # rather than the logical negation of Y:, so keep it as a standard
                    # conditional that sets the match flag to the evaluated result.
                    self.match_flag = bool(result)
                except:
                    # On error, default to no match
                    self.match_flag = False
                # mark that the last command set the match flag so a following T: can be conditional
                self._last_match_set = True
                return "continue"
                
            elif cmd_type == "J:":
                # Jump to label
                label = command[2:].strip()
                # If the previous command set a match (Y: or N:), treat this J:
                # as conditional: consume the sentinel and only jump when
                # match_flag is True. This matches examples that write
                # "Y:cond" followed by "J:label" as a conditional jump.
                if self._last_match_set:
                    # consume sentinel
                    self._last_match_set = False
                    if not self.match_flag:
                        return "continue"
                if label in self.labels:
                    return f"jump:{self.labels[label]}"
                return "continue"
                
            elif cmd_type == "M:":
                # Jump if match flag is set
                label = command[2:].strip()
                if self.match_flag and label in self.labels:
                    return f"jump:{self.labels[label]}"
                return "continue"
            elif cmd_type == "MT:":
                # Match-conditional text output: only output when match_flag is True
                text = command[3:].strip()
                if self.match_flag:
                    text = self.interpolate_text(text)
                    self.log_output(text)
                return "continue"
                
            elif cmd_type == "R:":
                # Gosub - subroutine call
                label = command[2:].strip()
                self.stack.append(self.current_line + 1)
                if label in self.labels:
                    return f"jump:{self.labels[label]}"
                return "continue"
                
            elif cmd_type == "C:":
                # Return from subroutine
                if self.stack:
                    return f"jump:{self.stack.pop()}"
                return "continue"
                
            elif cmd_type == "L:":
                # Label - do nothing
                return "continue"
                
            elif cmd_type == "U:":
                # Update variable
                assignment = command[2:].strip()
                if "=" in assignment:
                    var_name, expr = assignment.split("=", 1)
                    var_name = var_name.strip()
                    expr = expr.strip()
                    try:
                        value = self.evaluate_expression(expr)
                        self.variables[var_name] = value
                    except Exception as e:
                        self.log_output(f"Error in assignment {assignment}: {e}")
                return "continue"
                
            elif command.strip().upper() == "END":
                # End program
                return "end"
                
        except Exception as e:
            self.log_output(f"PILOT command error: {e}")
            return "continue"
            
        return "continue"
        
    def execute_basic_command(self, command):
        """Execute BASIC-like commands"""
        try:
            parts = command.split()
            if not parts:
                return "continue"
                
            cmd = parts[0].upper()
            
            if cmd == "LET":
                # Variable assignment
                if "=" in command:
                    _, assignment = command.split(" ", 1)
                    if "=" in assignment:
                        var_name, expr = assignment.split("=", 1)
                        var_name = var_name.strip()
                        expr = expr.strip()
                        try:
                            value = self.evaluate_expression(expr)
                            self.variables[var_name] = value
                        except Exception as e:
                            self.log_output(f"Error in LET {assignment}: {e}")
                return "continue"
            elif cmd == "IF":
                # IF condition THEN command  - evaluate condition, execute then-part if true
                try:
                    m = re.match(r"IF\s+(.+?)\s+THEN\s+(.+)", command, re.IGNORECASE)
                    if m:
                        cond_expr = m.group(1).strip()
                        then_cmd = m.group(2).strip()
                        try:
                            cond_val = self.evaluate_expression(cond_expr)
                        except Exception:
                            cond_val = False
                        if cond_val:
                            # Execute the THEN command using the general line executor so
                            # it can be a BASIC, PILOT or LOGO command fragment.
                            return self.execute_line(then_cmd)
                except Exception as e:
                    self.log_output(f"IF statement error: {e}")
                return "continue"
            elif cmd == "FOR":
                # FOR var = start TO end [STEP step]
                try:
                    m = re.match(r"FOR\s+([A-Za-z_]\w*)\s*=\s*(.+?)\s+TO\s+(.+?)(?:\s+STEP\s+(.+))?$", command, re.IGNORECASE)
                    if m:
                        var_name = m.group(1)
                        start_expr = m.group(2).strip()
                        end_expr = m.group(3).strip()
                        step_expr = m.group(4).strip() if m.group(4) else None

                        start_val = self.evaluate_expression(start_expr)
                        end_val = self.evaluate_expression(end_expr)
                        step_val = self.evaluate_expression(step_expr) if step_expr is not None else 1

                        # Integer-only loops: coerce start/end/step to int
                        try:
                            start_val = int(start_val)
                        except Exception:
                            start_val = 0
                        try:
                            end_val = int(end_val)
                        except Exception:
                            end_val = 0
                        try:
                            step_val = int(step_val)
                        except Exception:
                            step_val = 1

                        # Store the loop variable and position
                        self.variables[var_name] = start_val
                        self.for_stack.append({
                            'var': var_name,
                            'end': end_val,
                            'step': step_val,
                            'for_line': self.current_line
                        })
                except Exception as e:
                    self.log_output(f"FOR statement error: {e}")
                return "continue"
                
            elif cmd == "PRINT":
                # Print output
                text = command[5:].strip()
                if text.startswith('"') and text.endswith('"'):
                    # String literal
                    result = text[1:-1]
                else:
                    # Expression
                    try:
                        result = str(self.evaluate_expression(text))
                    except:
                        result = text
                self.log_output(result)
                return "continue"
            elif cmd == "REM":
                # Comment - ignore rest of the line
                return "continue"
            elif cmd == "END":
                return "end"
                
            elif cmd == "INPUT":
                # Get user input
                var_name = parts[1] if len(parts) > 1 else "INPUT"
                prompt = f"Enter value for {var_name}: " if len(parts) == 2 else "Enter value: "
                value = self.get_user_input(prompt)
                try:
                    if '.' in value:
                        self.variables[var_name] = float(value)
                    else:
                        self.variables[var_name] = int(value)
                except:
                    self.variables[var_name] = value
                return "continue"
                
            elif cmd == "GOTO":
                # Jump to line number
                if len(parts) > 1:
                    line_num = int(parts[1])
                    for i, (num, _) in enumerate(self.program_lines):
                        if num == line_num:
                            return f"jump:{i}"
                return "continue"

            elif cmd == "GOSUB":
                # Push return address and jump to line number
                if len(parts) > 1:
                    line_num = int(parts[1])
                    # push next-line index
                    self.stack.append(self.current_line + 1)
                    for i, (num, _) in enumerate(self.program_lines):
                        if num == line_num:
                            return f"jump:{i}"
                return "continue"

            elif cmd == "RETURN":
                # Return from GOSUB
                if self.stack:
                    return f"jump:{self.stack.pop()}"
                return "continue"

            elif cmd == "NEXT":
                # NEXT [var]
                try:
                    parts = command.split()
                    var_spec = parts[1] if len(parts) > 1 else None

                    # Find matching FOR on the stack
                    if not self.for_stack:
                        self.log_output("NEXT without FOR")
                        return "continue"

                    # If var specified, search from top for match, else take top
                    if var_spec:
                        # strip possible commas
                        var_spec = var_spec.strip()
                        found_idx = None
                        for i in range(len(self.for_stack)-1, -1, -1):
                            if self.for_stack[i]['var'].upper() == var_spec.upper():
                                found_idx = i
                                break
                        if found_idx is None:
                            self.log_output(f"NEXT for unknown variable {var_spec}")
                            return "continue"
                        ctx = self.for_stack[found_idx]
                        # remove any inner loops above this one? keep nested intact
                        # Only pop if loop finishes
                    else:
                        ctx = self.for_stack[-1]
                        found_idx = len(self.for_stack)-1

                    var_name = ctx['var']
                    step = int(ctx['step'])
                    end_val = int(ctx['end'])

                    # Ensure variable exists (treat as integer)
                    current_val = self.variables.get(var_name, 0)
                    try:
                        current_val = int(current_val)
                    except Exception:
                        current_val = 0

                    next_val = current_val + step
                    self.variables[var_name] = int(next_val)

                    # Decide whether to loop
                    loop_again = False
                    try:
                        if step >= 0:
                            loop_again = (next_val <= int(end_val))
                        else:
                            loop_again = (next_val >= int(end_val))
                    except Exception:
                        loop_again = False

                    if loop_again:
                        # jump to line after FOR statement
                        for_line = ctx['for_line']
                        return f"jump:{for_line+1}"
                    else:
                        # pop this FOR from stack
                        try:
                            self.for_stack.pop(found_idx)
                        except Exception:
                            pass
                except Exception as e:
                    self.log_output(f"NEXT statement error: {e}")
                return "continue"
                
        except Exception as e:
            self.log_output(f"BASIC command error: {e}")
            return "continue"
            
        return "continue"
        
    def execute_logo_command(self, command):
        """Execute Logo-like commands (simplified)"""
        try:
            parts = command.upper().split()
            if not parts:
                return "continue"
                
            cmd = parts[0]
            
            # This would interface with actual turtle graphics in full implementation
            if cmd in ["FORWARD", "FD", "BACK", "BK", "LEFT", "LT", "RIGHT", "RT"]:
                self.log_output(f"Logo command executed: {command}")
                return "continue"
                
            elif cmd in ["PENUP", "PU", "PENDOWN", "PD"]:
                self.log_output(f"Pen state changed: {command}")
                return "continue"
                
            elif cmd in ["CLEARSCREEN", "CS", "HOME"]:
                self.log_output(f"Screen command: {command}")
                return "continue"
                
            elif cmd == "SETXY":
                self.log_output(f"Turtle moved to position: {command}")
                return "continue"
                
        except Exception as e:
            self.log_output(f"Logo command error: {e}")
            return "continue"
            
        return "continue"
        
    def determine_command_type(self, command):
        """Determine which language the command belongs to"""
        command = command.strip()
        
        # PILOT commands start with a letter followed by colon
        if len(command) > 1 and command[1] == ':':
            return "pilot"
            
        # Logo commands
        logo_commands = ["FORWARD", "FD", "BACK", "BK", "LEFT", "LT", "RIGHT", "RT",
                        "PENUP", "PU", "PENDOWN", "PD", "CLEARSCREEN", "CS", "HOME", "SETXY"]
        if command.split()[0].upper() in logo_commands:
            return "logo"
            
        # BASIC commands
        basic_commands = ["LET", "PRINT", "INPUT", "GOTO", "IF", "THEN", "FOR", "TO", 
                         "NEXT", "GOSUB", "RETURN", "END", "REM"]
        if command.split()[0].upper() in basic_commands:
            return "basic"
            
        # Default to PILOT for simple commands
        return "pilot"
        
    def execute_line(self, line):
        """Execute a single line of code"""
        line_num, command = self.parse_line(line)
        
        if not command:
            return "continue"
            
        # Determine command type and execute
        cmd_type = self.determine_command_type(command)
        
        if cmd_type == "pilot":
            return self.execute_pilot_command(command)
        elif cmd_type == "basic":
            return self.execute_basic_command(command)
        elif cmd_type == "logo":
            return self.execute_logo_command(command)
            
        return "continue"
        
    def load_program(self, program_text):
        """Load and parse a program"""
        self.reset()
        lines = program_text.strip().split('\n')
        
        # Parse lines and collect labels
        self.program_lines = []
        for i, line in enumerate(lines):
            line_num, command = self.parse_line(line)
            self.program_lines.append((line_num, command))
            
            # Collect PILOT labels
            if command.startswith('L:'):
                label = command[2:].strip()
                self.labels[label] = i
                
        return True
        
    def run_program(self, program_text):
        """Run a complete program"""
        if not self.load_program(program_text):
            self.log_output("Error loading program")
            return False
            
        self.running = True
        self.current_line = 0
        max_iterations = 10000  # Prevent infinite loops
        iterations = 0
        
        try:
            while self.current_line < len(self.program_lines) and self.running and iterations < max_iterations:
                iterations += 1
                
                if self.debug_mode and self.current_line in self.breakpoints:
                    self.log_output(f"Breakpoint hit at line {self.current_line}")
                    # In a real debugger, this would pause execution
                    
                line_num, command = self.program_lines[self.current_line]
                
                # Skip empty lines
                if not command.strip():
                    self.current_line += 1
                    continue
                    
                result = self.execute_line(command)
                
                if result == "end":
                    break
                elif result.startswith("jump:"):
                    try:
                        jump_target = int(result.split(":")[1])
                        self.current_line = jump_target
                        continue
                    except:
                        pass
                elif result == "error":
                    self.log_output("Program terminated due to error")
                    break
                    
                self.current_line += 1
                
            if iterations >= max_iterations:
                self.log_output("Program stopped: Maximum iterations reached")
                
        except Exception as e:
            self.log_output(f"Runtime error: {e}")
        finally:
            self.running = False
            self.log_output("Program execution completed")
            
        return True

    # Debugger control methods
    def step(self):
        """Execute a single line and pause (for debugger stepping)."""
        if not self.program_lines:
            return
        if self.current_line >= len(self.program_lines):
            return
        line_num, command = self.program_lines[self.current_line]
        result = self.execute_line(command)
        if result.startswith("jump:"):
            try:
                jump_target = int(result.split(":")[1])
                self.current_line = jump_target
                return
            except Exception:
                pass
        elif result == "end":
            self.running = False
            return
        self.current_line += 1

    def continue_running(self):
        """Continue running until breakpoint or end."""
        self.running = True
        max_iterations = 10000
        iterations = 0
        try:
            while self.current_line < len(self.program_lines) and self.running and iterations < max_iterations:
                iterations += 1
                if self.debug_mode and self.current_line in self.breakpoints:
                    # Pause at breakpoint
                    break
                self.step()
            if iterations >= max_iterations:
                self.log_output("Program stopped: Maximum iterations reached")
        except Exception as e:
            self.log_output(f"Runtime error during continue: {e}")
        
    def stop_program(self):
        """Stop program execution"""
        self.running = False
        
    def set_debug_mode(self, enabled):
        """Enable/disable debug mode"""
        self.debug_mode = enabled
        
    def toggle_breakpoint(self, line_number):
        """Toggle breakpoint at line"""
        if line_number in self.breakpoints:
            self.breakpoints.remove(line_number)
        else:
            self.breakpoints.add(line_number)

# Demo program for testing
def create_demo_program():
    """Create a demo SuperPILOT program"""
    return '''L:START
T:Welcome to SuperPILOT Interpreter Demo!
A:NAME
T:Hello *NAME*! Let's do some math.
U:X=10
U:Y=20
T:X = *X*, Y = *Y*
U:SUM=*X*+*Y*
T:Sum of X and Y is *SUM*
T:
T:Let's count to 5:
U:COUNT=1
L:LOOP
Y:*COUNT* > 5
J:END_LOOP
T:Count: *COUNT*
U:COUNT=*COUNT*+1
J:LOOP
L:END_LOOP
T:
T:Random number: *RND(1)*
T:
T:What's your favorite number?
A:FAV_NUM
Y:*FAV_NUM* > 0
T:Great choice!
N:*FAV_NUM* <= 0
T:Zero or negative, interesting!
T:
T:Program completed. Thanks for using SuperPILOT!
END'''

# Simple test interface
def test_interpreter():
    """Test the interpreter with a simple interface"""
    print("SuperPILOT Interpreter Test")
    print("=" * 30)
    
    interpreter = SuperPILOTInterpreter()
    demo_program = create_demo_program()
    
    print("Demo program:")
    print(demo_program)
    print("\n" + "=" * 30)
    print("Program output:")
    
    interpreter.run_program(demo_program)
    
    print("=" * 30)
    print("Test completed")

# Integration with SuperPILOT II IDE
class SuperPILOTIDE:
    def __init__(self, root):
        self.root = root
        self.root.title("SuperPILOT IDE - Professional Edition")
        self.root.geometry("1000x700")
        # Apply a friendly theme and fonts
        self.setup_theme()
        
        # Initialize interpreter
        self.interpreter = SuperPILOTInterpreter()
        
        self.create_widgets()
        self.create_menu()
        
    def create_widgets(self):
        # Lightweight tooltip helper
        class ToolTip:
            def __init__(self, widget, text, delay=500):
                self.widget = widget
                self.text = text
                self.delay = delay
                self.tipwindow = None
                self.id = None
                widget.bind('<Enter>', self.schedule)
                widget.bind('<Leave>', self.hide)

            def schedule(self, event=None):
                self.id = self.widget.after(self.delay, self.show)

            def show(self):
                if self.tipwindow or not self.text:
                    return
                x = self.widget.winfo_rootx() + 20
                y = self.widget.winfo_rooty() + self.widget.winfo_height() + 5
                self.tipwindow = tw = tk.Toplevel(self.widget)
                tw.wm_overrideredirect(True)
                tw.wm_geometry(f"+{x}+{y}")
                label = tk.Label(tw, text=self.text, justify=tk.LEFT,
                                 background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                                 font=("Segoe UI", 9))
                label.pack(ipadx=4, ipady=2)

            def hide(self, event=None):
                if self.id:
                    try:
                        self.widget.after_cancel(self.id)
                    except Exception:
                        pass
                    self.id = None
                if self.tipwindow:
                    try:
                        self.tipwindow.destroy()
                    except Exception:
                        pass
                    self.tipwindow = None

        # Toolbar (modern, compact)
        toolbar = ttk.Frame(self.root)
        toolbar.pack(side=tk.TOP, anchor='nw', fill=tk.X, padx=5, pady=6)
        btn_style = {'padding': (6, 3)}

        # Create a horizontal split: editor on the left, output/variables/help on the right
        self.main_pane = tk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        self.main_pane.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Left pane: editor container
        self.editor_container = ttk.Frame(self.main_pane)
        self.main_pane.add(self.editor_container)

        # Right pane: notebook for Output, Variables, Help
        self.right_notebook = ttk.Notebook(self.main_pane)
        self.main_pane.add(self.right_notebook)

        # Try to create professional icons using Pillow; fall back to emoji/text labels
        try:
            from tools.icon_factory import create_toolbar_icons
            icons = create_toolbar_icons(self.root, size=18)
        except Exception:
            icons = {}

        def make_btn(key, text, cmd, padx=2):
            if icons and key in icons:
                # Show both icon and text for accessibility/clarity
                b = ttk.Button(toolbar, image=icons[key], text=text, compound='left', command=cmd, **btn_style)
                # Keep a reference to prevent garbage collection
                b.image = icons[key]
            else:
                b = ttk.Button(toolbar, text=text, command=cmd, **btn_style)
            b.pack(side=tk.LEFT, padx=padx)
            return b
        # Primary controls
        self.btn_run = make_btn('run', 'Run', self.run_program)
        self.btn_stop = make_btn('stop', 'Stop', self.stop_program)
        self.btn_debug = make_btn('debug', 'Debug', self.debug_program)
        # Step and Continue
        self.btn_step = make_btn('debug', 'Step', self.step_once)
        self.btn_continue = make_btn('run', 'Continue', self.continue_execution)
        # Separator
        sep = ttk.Separator(toolbar, orient='vertical')
        sep.pack(side=tk.LEFT, fill=tk.Y, padx=8)
        self.btn_load = make_btn('load', 'Load Demo', self.load_demo, padx=6)
        self.btn_save = make_btn('save', 'Save', self.save_file)

        # Right-aligned help button
        help_container = ttk.Frame(toolbar)
        help_container.pack(side=tk.RIGHT)
        if icons and 'help' in icons:
            self.btn_help = ttk.Button(help_container, image=icons['help'], text='Help', compound='left', command=lambda: messagebox.showinfo('Help', self.get_help_text()), padding=(6,3))
            self.btn_help.image = icons['help']
            self.btn_help.pack(side=tk.RIGHT)
        else:
            self.btn_help = ttk.Button(help_container, text='Help', command=lambda: messagebox.showinfo('Help', self.get_help_text()), padding=(6,3))
            self.btn_help.pack(side=tk.RIGHT)

        # Add tooltips
        try:
            ToolTip(self.btn_run, 'Run the program')
            ToolTip(self.btn_stop, 'Stop program execution')
            ToolTip(self.btn_debug, 'Run program in debug mode')
            ToolTip(self.btn_step, 'Execute one line (step)')
            ToolTip(self.btn_continue, 'Continue execution until breakpoint')
            ToolTip(self.btn_load, 'Load the demo program')
            ToolTip(self.btn_save, 'Save current file')
            ToolTip(self.btn_help, 'Open language reference and help')
        except Exception:
            pass

        # Initially disable Stop/Continue while idle
        try:
            self.btn_stop.state(['disabled'])
            self.btn_continue.state(['disabled'])
        except Exception:
            pass
        
        # Editor area placed in left pane
        self.editor_frame = ttk.Frame(self.editor_container)
        self.editor_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Text editor
        editor_frame = ttk.Frame(self.editor_frame)
        editor_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        self.editor = tk.Text(editor_frame, wrap=tk.NONE, font=("Consolas", 13),
                              bg="#fbfbfd", fg="#102a43", insertbackground="#1b3a57",
                              relief=tk.FLAT, bd=0)
        self.editor.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Scrollbars
        y_scrollbar = ttk.Scrollbar(editor_frame, orient=tk.VERTICAL, command=self.editor.yview)
        x_scrollbar = ttk.Scrollbar(editor_frame, orient=tk.HORIZONTAL, command=self.editor.xview)
        self.editor.config(yscrollcommand=y_scrollbar.set, xscrollcommand=x_scrollbar.set)

        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)

        # Control buttons under editor
        button_frame = ttk.Frame(self.editor_frame)
        button_frame.pack(fill=tk.X, padx=5, pady=5)

        ttk.Button(button_frame, text="Run", command=self.run_program).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Stop", command=self.stop_program).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Debug", command=self.debug_program).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Load Demo", command=self.load_demo).pack(side=tk.LEFT, padx=2)

        # Output tab placed on the right notebook
        self.output_frame = ttk.Frame(self.right_notebook)
        self.right_notebook.add(self.output_frame, text="Output")

        self.output_text = scrolledtext.ScrolledText(self.output_frame, wrap=tk.WORD,
                                                     font=("Segoe UI", 11), bg="#002b36", fg="#eee8d5")
        self.output_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Connect interpreter to output
        self.interpreter.output_widget = self.output_text

        # Status bar (bottom)
        self.status_bar = ttk.Label(self.root, text='Ready', anchor='w')
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

        # Bind editor events to update status (update_status may be defined elsewhere)
        try:
            self.editor.bind('<KeyRelease>', lambda e: self.update_status())
            self.editor.bind('<ButtonRelease>', lambda e: self.update_status())
        except Exception:
            pass

        # Variables tab on the right notebook
        self.variables_frame = ttk.Frame(self.right_notebook)
        self.right_notebook.add(self.variables_frame, text="Variables")

        self.variables_tree = ttk.Treeview(self.variables_frame, columns=('Value',), show='tree headings')
        self.variables_tree.heading('#0', text='Variable')
        self.variables_tree.heading('Value', text='Value')
        self.variables_tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Help tab on the right notebook
        self.help_frame = ttk.Frame(self.right_notebook)
        self.right_notebook.add(self.help_frame, text="Help")

        help_text = scrolledtext.ScrolledText(self.help_frame, wrap=tk.WORD)
        help_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        help_text.insert(1.0, self.get_help_text())
        help_text.config(state=tk.DISABLED, font=("Segoe UI", 10))

        # Current-line highlight tag
        try:
            self.editor.tag_configure('current_line', background='#263238')
        except Exception:
            pass

    def setup_theme(self):
        """Apply simple color scheme and font choices for a modern look."""
        try:
            style = ttk.Style(self.root)
            # Use a theme that supports customization if available
            if 'clam' in style.theme_names():
                style.theme_use('clam')
            style.configure('TButton', font=("Segoe UI", 10), foreground="#ffffff", background="#007acc")
            style.map('TButton', background=[('active', '#005f9e')])
            style.configure('TLabel', font=("Segoe UI", 10))
            style.configure('Treeview', font=("Segoe UI", 10))
            self.root.configure(bg='#f5f7fb')
        except Exception:
            pass
        
    def create_menu(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New", command=self.new_file)
        file_menu.add_command(label="Open", command=self.open_file)
        file_menu.add_command(label="Save", command=self.save_file)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)
        
        # Run menu
        run_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Run", menu=run_menu)
        run_menu.add_command(label="Run Program", command=self.run_program)
        run_menu.add_command(label="Debug Program", command=self.debug_program)
        run_menu.add_command(label="Stop Program", command=self.stop_program)
        
        # Examples menu
        examples_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Examples", menu=examples_menu)
        examples_menu.add_command(label="Hello World", command=self.load_hello_world)
        examples_menu.add_command(label="Math Demo", command=self.load_math_demo)
        examples_menu.add_command(label="Quiz Game", command=self.load_quiz_game)
        
        # View menu
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_command(label="Dark Mode", command=self.toggle_dark_mode)
    # end create_menu

    def get_help_text(self):
        return """
SUPERPILOT LANGUAGE REFERENCE

=== PILOT COMMANDS ===
T:text          - Output text (variables in *VAR* format). If a T: immediately
                  follows Y: or N: the T: is conditional and only prints when the
                  match flag is set; the sentinel is consumed by this T:.
A:variable      - Accept input into variable
Y:condition     - Set the match flag when condition is TRUE (and mark the next
                  T: or J: as a conditional consumer)
N:condition     - Set the match flag when condition is TRUE (used as an
                  alternate conditional in many sample programs)
J:label         - Jump to label. If J: immediately follows a Y: or N:, it will be
                  treated as a conditional jump (consumes the sentinel and jumps
                  only when the match flag is set).
M:label         - Jump to label if match flag is set (does not consume the sentinel)
R:label         - Gosub to label (subroutine call)
C:              - Return from subroutine
L:label         - Label definition
U:var=expr      - Update/Set variable
END             - End program

=== BASIC COMMANDS ===
LET var = expr  - Assign expression to variable
PRINT expr      - Output expression or string
INPUT var       - Get input into variable
GOTO line       - Jump to line number
IF condition THEN command  - Conditional execution
END             - End program
REM comment     - Comment

=== EXPRESSIONS ===
Supported operations: +, -, *, /, (), >, <, >=, <=, ==, !=
Built-in functions:
  RND()         - Random number 0-1
  INT(expr)     - Integer conversion
  VAL(string)   - Convert string to number
  UPPER(string) - Convert to uppercase
  LOWER(string) - Convert to lowercase
  MID(string,start,length) - Extract substring

=== EXAMPLE PROGRAM ===
L:START
T:Welcome to SuperPILOT!
A:NAME
T:Hello *NAME*!
U:SCORE=0
U:X=10
U:Y=20
T:X+Y = *X*+*Y*
U:SUM=*X*+*Y*
T:Sum is *SUM*
END
"""
                # ...create_menu continues...
        
    def run_program(self):
        program_text = self.editor.get(1.0, tk.END)
        self.output_text.delete(1.0, tk.END)
        # Update UI state
        try:
            self.btn_run.state(['disabled'])
            self.btn_stop.state(['!disabled'])
            self.btn_continue.state(['disabled'])
        except Exception:
            pass
        self.interpreter.run_program(program_text)
        try:
            self.btn_run.state(['!disabled'])
            self.btn_stop.state(['disabled'])
            self.btn_continue.state(['!disabled'])
        except Exception:
            pass
        self.update_variables_display()
        # Clear any current-line highlight after a full run
        try:
            self.editor.tag_remove('current_line', '1.0', tk.END)
        except Exception:
            pass
        
    def debug_program(self):
        self.interpreter.set_debug_mode(True)
        self.run_program()

    def step_once(self):
        """Execute a single interpreter line and update UI."""
        try:
            # Ensure program is loaded
            program_text = self.editor.get(1.0, tk.END)
            if not self.interpreter.program_lines:
                self.interpreter.load_program(program_text)
                self.interpreter.running = True
            self.interpreter.step()
            self.update_variables_display()
            # Show current line in output for visibility
            self.output_text.insert(tk.END, f"Stepped to line {self.interpreter.current_line}\n")
            # Highlight current line in editor
            try:
                self.highlight_current_line()
            except Exception:
                pass
        except Exception:
            pass

    def continue_execution(self):
        """Continue execution until next breakpoint or end and update UI."""
        try:
            program_text = self.editor.get(1.0, tk.END)
            if not self.interpreter.program_lines:
                self.interpreter.load_program(program_text)
            self.interpreter.set_debug_mode(True)
            try:
                self.btn_continue.state(['disabled'])
                self.btn_stop.state(['!disabled'])
            except Exception:
                pass
            self.interpreter.continue_running()
            try:
                self.btn_continue.state(['!disabled'])
                self.btn_stop.state(['disabled'])
            except Exception:
                pass
            self.update_variables_display()
            self.output_text.insert(tk.END, "Continue finished or paused at breakpoint\n")
            try:
                self.highlight_current_line()
            except Exception:
                pass
        except Exception:
            pass
        
    def stop_program(self):
        self.interpreter.stop_program()
        self.output_text.insert(tk.END, "Program execution stopped by user\n")
        
    def update_variables_display(self):
        # Clear existing items
        for item in self.variables_tree.get_children():
            self.variables_tree.delete(item)
            
        # Add variables
        for var_name, var_value in self.interpreter.variables.items():
            self.variables_tree.insert("", "end", text=var_name, values=(var_value,))

    def highlight_current_line(self):
        """Highlight the current interpreter line in the editor."""
        # Remove previous
        try:
            self.editor.tag_remove('current_line', '1.0', tk.END)
        except Exception:
            pass

        try:
            idx = self.interpreter.current_line
            if idx is None:
                return
            # program_lines maps directly to editor lines when loaded from editor text
            if 0 <= idx < len(self.interpreter.program_lines):
                line_no = idx + 1
                self.editor.tag_add('current_line', f"{line_no}.0", f"{line_no}.end")
                # Ensure visible
                self.editor.see(f"{line_no}.0")
        except Exception:
            pass

    # Theme helpers
    def toggle_dark_mode(self):
        # Toggle between light and dark
        try:
            current = self.editor.cget('bg')
            if current in ['#fbfbfd', 'white']:
                self.apply_dark_mode()
                self.persist_theme(True)
            else:
                self.apply_light_mode()
                self.persist_theme(False)
        except Exception:
            pass

    def apply_dark_mode(self):
        self.editor.config(bg='#0b1220', fg='#e6f0ff', insertbackground='#e6f0ff')
        try:
            self.line_numbers.config(bg='#071427', fg='#9fb7d5')
        except Exception:
            pass
        try:
            self.output_text.config(bg='#011627', fg='#d6f3ff')
        except Exception:
            pass

    def apply_light_mode(self):
        self.editor.config(bg='#fbfbfd', fg='#102a43', insertbackground='#1b3a57')
        try:
            self.line_numbers.config(bg='#f0f0f0', fg='#666666')
        except Exception:
            pass
        try:
            self.output_text.config(bg='#002b36', fg='#eee8d5')
        except Exception:
            pass

    def persist_theme(self, dark_mode: bool):
        try:
            from tools.theme import load_config, save_config
            cfg = load_config()
            cfg['dark_mode'] = bool(dark_mode)
            save_config(cfg)
        except Exception:
            pass
            
    def new_file(self):
        self.editor.delete(1.0, tk.END)
        
    def open_file(self):
        from tkinter import filedialog
        file_path = filedialog.askopenfilename(
            filetypes=[("SuperPILOT Files", "*.spt"), ("Text Files", "*.txt"), ("All Files", "*.*")]
        )
        if file_path:
            with open(file_path, "r") as file:
                content = file.read()
                self.editor.delete(1.0, tk.END)
                self.editor.insert(1.0, content)
                
    def save_file(self):
        from tkinter import filedialog
        file_path = filedialog.asksaveasfilename(
            defaultextension=".spt",
            filetypes=[("SuperPILOT Files", "*.spt"), ("Text Files", "*.txt"), ("All Files", "*.*")]
        )
        if file_path:
            content = self.editor.get("1.0", tk.END)
            with open(file_path, "w") as file:
                file.write(content)
            messagebox.showinfo("Save", "File saved successfully!")
            
    def load_demo(self):
        self.editor.delete(1.0, tk.END)
        self.editor.insert(1.0, create_demo_program())
        
    def load_hello_world(self):
        program = '''L:START
T:Hello, World!
T:This is SuperPILOT!
END'''
        self.editor.delete(1.0, tk.END)
        self.editor.insert(1.0, program)
        
    def load_math_demo(self):
        program = '''L:START
T:SuperPILOT Math Demo
U:A=15
U:B=25
T:A = *A*, B = *B*
U:SUM=*A*+*B*
U:DIFF=*A*-*B*
U:PRODUCT=*A***B*
T:Sum: *SUM*
T:Difference: *DIFF*
T:Product: *PRODUCT*
T:Random: *RND(1)*
END'''
        self.editor.delete(1.0, tk.END)
        self.editor.insert(1.0, program)
        
    def load_quiz_game(self):
        program = '''L:START
T:SuperPILOT Quiz Game
A:PLAYER
T:Welcome *PLAYER*!
U:SCORE=0

L:QUESTION1
T:Question 1: What is 2+2?
A:ANSWER1
Y:*ANSWER1* == 4
T:Correct! +10 points
U:SCORE=*SCORE*+10
N:*ANSWER1* != 4
T:Wrong! The answer is 4

L:QUESTION2
T:Question 2: What is 5*3?
A:ANSWER2
Y:*ANSWER2* == 15
T:Correct! +10 points
U:SCORE=*SCORE*+10
N:*ANSWER2* != 15
T:Wrong! The answer is 15

L:RESULTS
T:*PLAYER*, your final score is *SCORE*
Y:*SCORE* >= 20
T:Excellent!
N:*SCORE* < 20
T:Keep practicing!
END'''
        self.editor.delete(1.0, tk.END)
        self.editor.insert(1.0, program)

def main():
    root = tk.Tk()
    app = SuperPILOTIDE(root)
    
    # Show welcome message
    root.after(1000, lambda: messagebox.showinfo("Welcome to SuperPILOT IDE", 
                "Welcome to SuperPILOT IDE - Professional Edition!\n\n"
                "Features:\n"
                " Complete PILOT/BASIC/Logo interpreter\n"
                " Integrated development environment\n"
                " Real-time variable monitoring\n"
                " Built-in examples and help\n"
                " Debugging capabilities\n\n"
                "Load an example or write your own program!"))
    
    root.mainloop()

if __name__ == "__main__":
    # You can run either the test or the full IDE
    # test_interpreter()  # For command-line testing
    main()  # For full GUI IDE
